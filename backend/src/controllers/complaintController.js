const Complaint = require('../models/Complaint');
const { predictCategory, analyzeUrgency } = require('../services/aiService');

// @desc    Create new complaint
// @route   POST /api/complaints
// @access  Private
exports.createComplaint = async (req, res) => {
    try {
        const {
            title,
            description,
            location,
            latitude,
            longitude,
            urgency, // User provided urgency
            severity, // JSON string or object
        } = req.body;

        if (!title || !description || !location) {
            return res.status(400).json({ message: 'Please fill in all required fields' });
        }

        // AI Analysis (now async)
        const aiCategory = await predictCategory(description + ' ' + title);
        const aiUrgency = await analyzeUrgency(description);

        // Parse severity if it's a string (from FormData)
        let parsedSeverity = {
            traffic_block: false,
            water_leak: false,
            electricity_risk: false,
            fire_hazard: false
        };

        if (severity) {
            try {
                parsedSeverity = typeof severity === 'string' ? JSON.parse(severity) : severity;
            } catch (e) {
                console.error("Error parsing severity:", e);
            }
        }

        // Handle Images - Cloudinary URLs are in file.path
        const imagePaths = req.files ? req.files.map(file => file.path) : [];

        const complaint = await Complaint.create({
            user: req.user.id,
            title,
            description,
            location,
            latitude: latitude ? Number(latitude) : null,
            longitude: longitude ? Number(longitude) : null,
            category: aiCategory,
            urgency: urgency ? Number(urgency) : aiUrgency,
            severity: parsedSeverity,
            images: imagePaths,
            aiMeta: {
                model: process.env.GEMINI_API_KEY ? "Gemini-Pro" : "Rule-Based-v1",
                confidence: process.env.GEMINI_API_KEY ? 0.95 : 0.8,
                autoGenerated: true
            }
        });

        res.status(201).json(complaint);
    } catch (error) {
        console.error(error);
        res.status(500).json({ message: 'Server Error' });
    }
};

// @desc    Get user complaints (with filtering & sorting)
// @route   GET /api/complaints
// @access  Private
exports.getMyComplaints = async (req, res) => {
    try {
        const { status, category, sort } = req.query;

        let filter = { user: req.user.id };

        if (status) filter.status = status;
        if (category) filter.category = category;

        let sortOption = { createdAt: -1 }; // Default: Latest
        if (sort === 'oldest') sortOption = { createdAt: 1 };

        const complaints = await Complaint.find(filter).sort(sortOption);
        res.json(complaints);
    } catch (error) {
        console.error(error);
        res.status(500).json({ message: 'Server Error' });
    }
};

// @desc    Get single complaint
// @route   GET /api/complaints/:id
// @access  Private
exports.getComplaintById = async (req, res) => {
    try {
        const complaint = await Complaint.findById(req.params.id);

        if (!complaint) {
            return res.status(404).json({ message: 'Complaint not found' });
        }

        // Ensure user owns the complaint or is admin (though this route is primarily for citizens)
        if (complaint.user.toString() !== req.user.id && req.user.role !== 'admin') {
            return res.status(403).json({ message: 'Not authorized' });
        }

        res.json(complaint);
    } catch (error) {
        console.error(error);
        res.status(500).json({ message: 'Server Error' });
    }
};

// @desc    Update complaint (Citizen)
// @route   PUT /api/complaints/:id
// @access  Private
exports.updateMyComplaint = async (req, res) => {
    try {
        const complaint = await Complaint.findById(req.params.id);

        if (!complaint) {
            return res.status(404).json({ message: 'Complaint not found' });
        }

        if (complaint.user.toString() !== req.user.id) {
            return res.status(403).json({ message: 'Not authorized' });
        }

        if (complaint.isLocked || complaint.status !== 'Pending') {
            return res.status(400).json({ message: 'Cannot edit complaint after it is processed' });
        }

        const updatedComplaint = await Complaint.findByIdAndUpdate(
            req.params.id,
            req.body,
            { new: true }
        );

        res.json(updatedComplaint);
    } catch (error) {
        console.error(error);
        res.status(500).json({ message: 'Server Error' });
    }
};

// @desc    Delete complaint (Citizen)
// @route   DELETE /api/complaints/:id
// @access  Private
exports.deleteComplaint = async (req, res) => {
    try {
        const complaint = await Complaint.findById(req.params.id);

        if (!complaint) {
            return res.status(404).json({ message: 'Complaint not found' });
        }

        if (complaint.user.toString() !== req.user.id) {
            return res.status(403).json({ message: 'Not authorized' });
        }

        if (complaint.status !== 'Pending') {
            return res.status(400).json({ message: 'Cannot delete processed complaint' });
        }

        // Soft delete if schema supports it, otherwise hard delete
        if (complaint.isDeleted !== undefined) {
            complaint.isDeleted = true;
            await complaint.save();
        } else {
            await complaint.deleteOne();
        }

        res.json({ message: 'Complaint removed' });
    } catch (error) {
        console.error(error);
        res.status(500).json({ message: 'Server Error' });
    }
};
